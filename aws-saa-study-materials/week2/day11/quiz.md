# Day 11 퀴즈: DynamoDB

## 퀴즈 개요
- **주제**: Amazon DynamoDB
- **문제 수**: 5문제
- **예상 소요 시간**: 10-15분
- **난이도**: 중급
- **학습 목표**: DynamoDB의 핵심 개념, 데이터 모델링, 성능 최적화 이해도 확인

---

## 문제 1: DynamoDB 기본 개념

**다음 중 DynamoDB의 특징으로 올바르지 않은 것은?**

A) 완전 관리형 NoSQL 데이터베이스 서비스이다
B) 서버리스 아키텍처를 지원한다
C) 복잡한 조인 쿼리를 효율적으로 처리할 수 있다
D) 자동으로 확장되어 높은 가용성을 제공한다

<details>
<summary><strong>정답 및 해설</strong></summary>

**정답: C) 복잡한 조인 쿼리를 효율적으로 처리할 수 있다**

**해설:**
DynamoDB는 NoSQL 데이터베이스로서 관계형 데이터베이스의 조인 연산을 지원하지 않습니다. 대신 단일 테이블 설계나 애플리케이션 레벨에서 데이터를 조합하는 방식을 사용해야 합니다.

- A) 올바름: DynamoDB는 AWS에서 완전히 관리하는 NoSQL 데이터베이스입니다
- B) 올바름: 서버 관리가 불필요한 서버리스 서비스입니다
- D) 올바름: 트래픽에 따라 자동으로 확장되며 99.99% 가용성을 제공합니다

**관련 개념:**
- NoSQL vs SQL 데이터베이스의 차이점
- DynamoDB의 단일 테이블 설계 패턴
- 애플리케이션 레벨에서의 데이터 조합 전략
</details>

---

## 문제 2: 기본 키 설계

**전자상거래 애플리케이션에서 사용자별 주문 내역을 저장하는 DynamoDB 테이블을 설계할 때, 다음 중 가장 적절한 기본 키 구성은?**

A) 파티션 키: order_id
B) 파티션 키: user_id, 정렬 키: order_id
C) 파티션 키: order_date, 정렬 키: user_id
D) 파티션 키: user_id, 정렬 키: order_date

<details>
<summary><strong>정답 및 해설</strong></summary>

**정답: B) 파티션 키: user_id, 정렬 키: order_id**

**해설:**
전자상거래에서 가장 일반적인 액세스 패턴은 "특정 사용자의 주문 내역 조회"입니다. 이 경우 user_id를 파티션 키로, order_id를 정렬 키로 사용하는 것이 가장 효율적입니다.

**각 옵션 분석:**
- A) order_id만 사용: 사용자별 주문 조회 시 전체 테이블 스캔 필요
- B) **최적**: 사용자별 주문 조회가 효율적이며, 특정 주문도 빠르게 조회 가능
- C) order_date + user_id: 날짜별 조회는 가능하지만 사용자별 조회가 비효율적
- D) user_id + order_date: 사용자별 조회는 가능하지만 특정 주문 조회 시 날짜를 알아야 함

**설계 원칙:**
- 가장 빈번한 액세스 패턴을 기준으로 파티션 키 선택
- 정렬 키는 범위 쿼리나 고유성 보장에 활용
- 데이터 분산을 고려한 파티션 키 설계
</details>

---

## 문제 3: 읽기 일관성

**DynamoDB에서 읽기 일관성에 대한 설명으로 올바른 것은?**

A) 강한 일관성(Strong Consistency)이 기본 설정이며 항상 최신 데이터를 반환한다
B) 최종 일관성(Eventually Consistent)은 더 높은 비용이 발생한다
C) 글로벌 보조 인덱스(GSI)는 강한 일관성을 지원한다
D) 최종 일관성 읽기는 강한 일관성 읽기보다 더 높은 처리량을 제공한다

<details>
<summary><strong>정답 및 해설</strong></summary>

**정답: D) 최종 일관성 읽기는 강한 일관성 읽기보다 더 높은 처리량을 제공한다**

**해설:**
DynamoDB의 읽기 일관성 모델에서 최종 일관성 읽기가 더 높은 성능과 처리량을 제공합니다.

**각 옵션 분석:**
- A) 틀림: 최종 일관성이 기본 설정이며, 강한 일관성은 옵션으로 선택해야 함
- B) 틀림: 강한 일관성이 더 높은 비용 발생 (읽기 용량 단위 2배 소비)
- C) 틀림: GSI는 최종 일관성만 지원함
- D) **정답**: 최종 일관성은 더 빠른 응답 시간과 높은 처리량 제공

**일관성 모델 비교:**
- **최종 일관성**: 기본값, 빠른 성능, 저렴한 비용, 최신 데이터가 아닐 수 있음
- **강한 일관성**: 옵션, 항상 최신 데이터, 높은 비용, 약간 느린 성능

**실제 사용 시나리오:**
- 최종 일관성: 소셜 미디어 피드, 상품 목록 등
- 강한 일관성: 금융 거래, 재고 관리 등
</details>

---

## 문제 4: 성능 최적화

**DynamoDB에서 "핫 파티션" 문제가 발생했을 때, 다음 중 가장 효과적인 해결 방법은?**

A) 읽기/쓰기 용량 단위를 증가시킨다
B) 파티션 키에 랜덤 접미사를 추가하여 데이터를 더 균등하게 분산시킨다
C) 글로벌 보조 인덱스(GSI)를 추가한다
D) 온디맨드 모드로 변경한다

<details>
<summary><strong>정답 및 해설</strong></summary>

**정답: B) 파티션 키에 랜덤 접미사를 추가하여 데이터를 더 균등하게 분산시킨다**

**해설:**
핫 파티션 문제는 특정 파티션에 트래픽이 집중되어 발생하는 문제로, 근본적인 해결책은 데이터를 더 균등하게 분산시키는 것입니다.

**핫 파티션 문제 원인:**
- 순차적인 키 사용 (예: 타임스탬프)
- 인기 있는 특정 키에 트래픽 집중
- 불균등한 데이터 분산

**각 해결 방법 분석:**
- A) 임시방편: 용량 증가로는 근본 원인 해결 안 됨
- B) **최적**: 데이터 분산을 개선하여 근본 원인 해결
- C) 부분적 도움: 읽기 패턴 다양화에는 도움되지만 쓰기 핫스팟은 해결 안 됨
- D) 임시방편: 자동 확장으로 완화되지만 근본 해결책 아님

**구체적인 해결 전략:**
- 랜덤 접미사: `user123_A7B2`, `user123_C9D1`
- 역순 타임스탬프: `20240115` → `51510402`
- 해시 기반 분산: 일관된 해싱 알고리즘 사용
</details>

---

## 문제 5: 시나리오 기반 문제

**게임 애플리케이션에서 실시간 리더보드를 구현하려고 합니다. 다음 요구사항을 만족하는 DynamoDB 테이블 설계로 가장 적절한 것은?**

**요구사항:**
- 게임별 상위 100명의 점수 조회
- 특정 사용자의 순위 조회
- 새로운 점수 업데이트 시 실시간 반영

A) 파티션 키: game_id, 정렬 키: user_id
B) 파티션 키: game_id, 정렬 키: score (내림차순)
C) 파티션 키: user_id, 정렬 키: game_id
D) 파티션 키: score, 정렬 키: user_id

<details>
<summary><strong>정답 및 해설</strong></summary>

**정답: B) 파티션 키: game_id, 정렬 키: score (내림차순)**

**해설:**
리더보드의 핵심 요구사항은 "게임별 점수 순위 조회"이므로, game_id를 파티션 키로, score를 정렬 키로 사용하는 것이 가장 효율적입니다.

**설계 분석:**
- **파티션 키 (game_id)**: 게임별로 데이터 분리
- **정렬 키 (score, 내림차순)**: 높은 점수부터 자동 정렬
- **상위 100명 조회**: `Query` 작업으로 `Limit=100` 설정
- **특정 사용자 순위**: GSI 필요 (user_id 기반)

**각 옵션 분석:**
- A) 점수 순위 조회 시 전체 스캔 후 정렬 필요 (비효율적)
- B) **최적**: 점수 순위 조회가 매우 효율적
- C) 게임별 조회가 어려움
- D) 게임 구분이 어려움

**추가 고려사항:**
```
기본 테이블: game_id (PK) + score (SK, 내림차순)
GSI: user_id (PK) + game_id (SK) - 사용자별 게임 기록 조회용

데이터 예시:
- PK: "game001", SK: 9999 (1등 점수)
- PK: "game001", SK: 9850 (2등 점수)
- PK: "game001", SK: 9720 (3등 점수)
```

**실시간 업데이트 전략:**
- DynamoDB Streams + Lambda로 순위 변동 알림
- 점수 업데이트 시 기존 기록 삭제 후 새 기록 생성
- TTL 설정으로 오래된 기록 자동 정리
</details>

---

## 퀴즈 완료 후 학습 점검

### 점수별 학습 가이드

**5문제 모두 정답 (100점)**
- 🎉 훌륭합니다! DynamoDB의 핵심 개념을 잘 이해하고 있습니다
- 다음 단계: 고급 기능 (Streams, Global Tables) 학습
- 실습 권장: 복잡한 애플리케이션 시나리오 설계

**4문제 정답 (80점)**
- 👍 좋은 이해도를 보여줍니다
- 틀린 문제 영역 집중 복습 필요
- 실습 권장: 다양한 액세스 패턴 연습

**3문제 정답 (60점)**
- 📚 기본 개념은 이해했지만 추가 학습 필요
- 이론 내용 재검토 권장
- 실습 권장: 기본 CRUD 작업 반복 연습

**2문제 이하 정답 (40점 이하)**
- 📖 이론 내용 전체 재학습 권장
- 실습 가이드 단계별 재수행
- AWS 공식 문서 추가 참조

### 추가 학습 리소스

**AWS 공식 자료:**
- [DynamoDB 개발자 가이드](https://docs.aws.amazon.com/dynamodb/)
- [DynamoDB 모범 사례](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
- [DynamoDB 워크샵](https://amazon-dynamodb-labs.com/)

**실습 환경:**
- AWS Free Tier DynamoDB 한도 확인
- 실제 애플리케이션 시나리오 연습
- 성능 테스트 및 최적화 실습

### 내일 학습 예고

**Day 12: 데이터 마이그레이션 서비스**
- AWS Database Migration Service (DMS)
- 온프레미스에서 클라우드로의 마이그레이션
- 동종/이종 데이터베이스 마이그레이션
- 실시간 복제 및 최소 다운타임 전략

오늘 학습한 DynamoDB 지식을 바탕으로 내일은 기존 데이터베이스를 AWS로 마이그레이션하는 방법을 학습하겠습니다!